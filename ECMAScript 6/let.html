<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>ES6 let</title>
</head>
<body>
<ol>
  <li>
    let 所声明的变量，只在 let 命令所在的代码块内有效。很适合 for 循环计数器。<br/>
    <samp>
      {<br/>
      &nbsp;&nbsp;var a = 1;<br/>
      &nbsp;&nbsp;let b = 1; //b 在代码块外部无效<br/>
      }
      <hr/>
        <pre>var a = [];
for (var i = 0; i < 10; i++) {
  a[i] = function () {
    console.log(i);
  };
}
a[0](); // 10，因为 i 是全局变量</pre>
      <hr/>
    <pre>var a = [];
for (let i = 0; i < 10; i++) {
  a[i] = function () {
    console.log(i);
  };
}
a[6](); // 6，因为 i 是局部变量</pre>
      <hr/>
      <pre>for (var i = 0; i < 3; i++) { //输出1次 abc
  var i = 'abc';
  console.log(i);
}
      </pre>
      <hr/>
      <pre>for (let i = 0; i < 3; i++) { //输出3次 abc，函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域。
  let i = 'abc';
  console.log(i);
}
      </pre>
    </samp>
  </li>
  <li>
    除去“变量提升”（即变量可以在声明之前使用，值为 undefined）。<br/>
    <samp>
      <pre>console.log(foo); // 输出undefined
var foo = 2;</pre>
      <hr/>
      <pre>console.log(bar); // 报错ReferenceError
let bar = 2;</pre>
    </samp>
  </li>
  <li>
    暂时性死区（temporal dead zone，简称 TDZ）（在代码块内，使用 let 或 const 命令声明变量之前，该变量都是不可用的）。<br/>
    <samp>
      <pre>var tmp = 123;
if (true) {
  tmp = 'abc'; // ReferenceError
  let tmp;
}</pre>
      <hr/>
      <pre>{
  // TDZ开始
  tmp = 'abc'; // ReferenceError
  console.log(tmp); // ReferenceError

  let tmp; // TDZ结束
  console.log(tmp); // undefined

  tmp = 123;
  console.log(tmp); // 123
}</pre>
    </samp>
  </li>
  <li>
    不允许重复声明。<br/>
    <samp>
      <pre>function func() {//报错
  let a = 10;
  var a = 1;
}
func()</pre>
      <hr/>
      <pre>function func() {//报错
  let a = 10;
  let a = 1;
}
func()</pre>
      <hr/>
      <pre>function func(arg) {//报错
  let arg;
}
func()</pre>
      <hr/>
      <pre>function func(arg) {//不报错
  {
    let arg;
  }
}
func()</pre>
    </samp>
  </li>
  <li>
    let 的块级作用域。<br/>
    <samp>
      <pre>var tmp = new Date();
function f() {
  console.log(tmp);
  if (false) {
    var tmp = 'hello world';
  }
}
f(); // undefined，变量提升，导致内层的tmp变量覆盖了外层的tmp变量</pre>
      <hr/>
      <pre>var tmp = new Date();
function f() {
  console.log(tmp);
  if (false) {
    let tmp = 'hello world';
  }
}
f();</pre>
    </samp>
  </li>
  <li>
    块级作用域与函数声明。<br/>
    <ol>
      <li>允许在块级作用域内声明函数。</li>
      <li>函数声明类似于var，即会提升到全局作用域或函数作用域的头部。</li>
      <li>同时，函数声明还会提升到所在的块级作用域的头部。</li>
    </ol>
    根据这三条规则，在浏览器的 ES6 环境中，块级作用域内声明的函数，行为类似于var声明的变量。<br/>
    <samp>
      <pre>// 浏览器的 ES6 环境
function f() { console.log('I am outside!'); }

(function () {
  if (false) {
    // 重复声明一次函数f
    function f() { console.log('I am inside!'); }
  }

  f();
}());
// Uncaught TypeError: f is not a function，等价于下面一段代码</pre>
      <hr/>
      <pre>// 浏览器的 ES6 环境
function f() { console.log('I am outside!'); }
(function () {
  var f = undefined;
  if (false) {
    function f() { console.log('I am inside!'); }
  }

  f();
}());
// Uncaught TypeError: f is not a function</pre>
      <hr/>
      //考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。
      <pre>{
  let a = 'secret';
  function f() {
    return a;
  }
}
f(); //secret</pre>
      <hr/>
      <pre>{
  let a = 'secret';
  let f = function () {
    return a;
  };
}
f(); //ReferenceError</pre>
      <hr/>
      //ES6 的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。
      <pre>'use strict';
if (true) {
  function f() {}
}</pre>
      <hr/>
      <pre>// 报错
'use strict';
if (true)
  function f() {}</pre>
    </samp>
  </li>
  <li>
    const声明一个只读的常量。一旦声明，常量的值就不能改变。声明时必须初始化。<br/>
    作用域与 let 命令相同。也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。<br/>
    <samp>
      const PI = 3.1415;<br/>
      PI // 3.1415<br/>
      PI = 3; // TypeError: Assignment to constant variable.<br/>
    </samp>
  </li>
  <li>
    const本质。只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就不能控制了。<br/>
    <samp>
      const foo = {};<br/>
      foo.prop = 123;// 为 foo 添加一个属性，可以成功<br/>
      foo.prop // 123<br/>
      foo = {}; // 将 foo 指向另一个对象，就会报错： TypeError: "foo" is read-only<br/>
      <hr/>
      const a = [];<br/>
      a.push('Hello'); // 可执行<br/>
      a.length = 0;    // 可执行<br/>
      a = ['Dave'];    // 报错
      <hr/>
      //想将对象冻结，应该使用Object.freeze方法<br/>
      const foo = Object.freeze({});<br/>
      foo.prop = 123;// 常规模式时，下面一行不起作用；严格模式时，该行会报错<br/>
      <hr/>
      除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。<br/>
      <pre>var constantize = (obj) => {
  Object.freeze(obj);
  Object.keys(obj).forEach( (key, i) => {
    if ( typeof obj[key] === 'object' ) {
      constantize( obj[key] );
    }
  });
};</pre>
    </samp>
  </li>
  <li>
    ES6 的六种声明变量的方法。<br/>
    <samp>
      <ol>
        <li>var (ES5)</li>
        <li>function (ES5)</li>
        <li>let</li>
        <li>const</li>
        <li>import</li>
        <li>class</li>
      </ol>
    </samp>
    为了保持兼容性，var 命令和 function 命令声明的全局变量，依旧是顶层对象的属性；<br/>
    另一方面规定，let 命令、const 命令、class 命令声明的全局变量，不属于顶层对象的属性。<br/>
    也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。
    <samp>
      <pre>var a = 1;
// 如果在 Node 的 REPL 环境，可以写成 global.a
// 或者采用通用方法，写成 this.a
window.a // 1

let b = 1;
window.b // undefined</pre>
    </samp>
  </li>
</ol>
</body>
<script>

</script>
</html>