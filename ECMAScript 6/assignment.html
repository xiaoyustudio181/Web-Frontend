<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>ES6 变量的解构赋值</title>
</head>
<body>
<ol>
  <li>
    从数组中提取值，按照对应位置，对变量赋值。<br/>
    <samp>
      let [a, b, c] = [1, 2, 3];
    </samp>
  </li>
  <li>
    解构不成功，变量的值等于 undefined。<br/>
    <samp>
      let [a] = [];<br/>
      let [a, b] = [1];
    </samp>
  </li>
  <li>
    不完全解构。<br/>
    <samp>
      let [x, y] = [1, 2, 3];
    </samp>
  </li>
  <li>
    等号的右边不是数组（不是可遍历的结构），会报错。<br/>
    <samp>
      let [foo] = 1;<br/>
      let [foo] = false;<br/>
      let [foo] = NaN;<br/>
      let [foo] = undefined;<br/>
      let [foo] = null;<br/>
      let [foo] = {};
    </samp>
  </li>
  <li>
    默认值。<br/>
    <samp>
      let [foo = true] = []; //foo=true<br/>
      let [x, y = 'b'] = ['a']; // x='a', y='b'<br/>
      let [x, y = 'b'] = ['a', undefined]; // x='a', y='b'<br/>
      let [x = 1] = [undefined]; //x=1，只有当一个数组成员严格等于undefined，默认值才会生效<br/>
      let [x = 1] = [null]; //x=null
    </samp>
  </li>
  <li>
    表达式默认值。<br/>
    <samp>
      function f() { return 100; }<br/>
      let [x = f()] = [1]; //惰性求值的，即只有在用到的时候，才会求值。这里函数 f 不会执行。<hr/>
      function f() { return 100; }<br/>
      let [x = f()] = [undefined]; //x=100<br/>
    </samp>
  </li>
  <li>
    默认值可以引用解构赋值的其他变量，但该变量必须已经声明。<br/>
    <samp>
      let [x = 1, y = x] = [];     // x=1; y=1<br/>
      let [x = 1, y = x] = [2];    // x=2; y=2<br/>
      let [x = 1, y = x] = [1, 2]; // x=1; y=2<br/>
      let [x = y, y = 1] = [];     // ReferenceError: y is not defined
    </samp>
  </li>
</ol>

<ol>
  <li>
    对象的解构赋值。<br/>
    <samp>
      let { foo, bar, baz } = { foo: "aaa", bar: "bbb" }; //foo="aaa", bar="bbb", baz=undefined
    </samp>
  </li>
  <li>
    如果变量名与属性名不一致，必须写成这样。<br/>
    <samp>
      let { foo: baz } = { foo: 'aaa', bar: 'bbb' }; //baz='aaa'<br/>
      //从而得知对象解构的原型是：<br/>
      let { foo: foo, bar: bar } = { foo: "aaa", bar: "bbb" };
    </samp>
  </li>
  <li>
    与数组一样，解构也可以用于嵌套结构的对象。<br/>
    <samp>
      let { p: [x, { y }] } = { p: [ 'Hello', { y: 'World' } ] }; //x='Hello', y='World'<br/>
      //这时 p 是模式，不是变量，因此不会被赋值。如果 p 也要作为变量赋值，可以写成下面这样：<br/>
      let { p, p: [x, { y }] } = { p: [ 'Hello', { y: 'World' } ] }; //x='Hello', y='World', p=[ 'Hello', { y: 'World' } ]
    </samp>
  </li>
</ol>
</body>
</html>