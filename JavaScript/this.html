<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title></title>
    <script src="helper.js"></script>
</head>
<body>
<ol>
    <li>
        全局上下文。无论是否在严格模式下，在全局执行上下文中（在任何函数体外部）this 都指代全局对象。<br/>
        在浏览器中, window 对象同时也是全局对象：
        <script>
            write(this === window);//true
            var1 = 1;
            write(window.var1 === this.var1);//true
        </script>
    </li>
    <li>
        函数上下文。在函数内部，this的值取决于函数被调用的方式。
        <ol>
            <li>
                在非严格模式下，且 this 的值不是由该调用设置的，所以 this 的值默认指向全局对象。
                <script>
                    function returnthis() {
                        return this;
                    }

                    write(returnthis() === window);//true
                </script>
            </li>
            <li>
                在严格模式下，this将保持他进入执行上下文时的值，所以下面的this将会默认为undefined。<br/>
                在严格模式下，如果 this 没有被执行上下文（execution context）定义，那它将保持为 undefined。
                <script>
                    function returnthis2() {
                        'use strict';//严格模式
                        return this;
                    }

                    write(returnthis2() === window);//false
                    write(returnthis2() === undefined);//true
                </script>
            </li>
        </ol>
    </li>
    <li>
        如果要想把 this 的值从一个上下文传到另一个，就要用 call 或者 apply 方法。<br/>
        一个对象可以作为 call 和 apply 的第一个参数，并且this会被绑定到这个对象。
        <script>
            var person = {name: 'jerry', gender: 1};
            var name = 'tom';

            function whatsThis() {
                write(this.name);
            }

            whatsThis();
            whatsThis.call(person);
            whatsThis.apply(person);
        </script>
    </li>
    <li>
        当一个函数在其主体中使用 this 关键字时，可以通过使用函数继承自 Function.prototype 的 call 或 apply 方法将 this 值绑定到调用中的特定对象。<br/>
        func.call(obj,param1,param2...)，第一个参数是作为 this 使用的对象，后续参数作为参数传递给函数调用。<br/>
        func.apply(obj,[param1,param2...)，第一个参数也是作为 this 使用的对象，第二个参数是一个数组，数组里的元素用作函数调用中的参数。<br/>
        使用 call 和 apply 函数的时候要注意，如果传递给 this 的值不是一个对象，JavaScript 会尝试使用内部 ToObject 操作将其转换为对象。
        <script>
            function add(param1, param2) {
                var result = this.num1 + this.num2 + param1 + param2;
                write(result);
            }

            var nums = {num1: 10, num2: 20};
            add.call(nums, 2, 3);
            add.apply(nums, [2, 3]);
        </script>
    </li>
    <li>
        func.bind(obj)，创建一个与 func 具有相同函数体和作用域的函数，但是在这个新函数中，this将永久地被绑定到了bind的第一个参数，无论这个函数是如何被调用的。
        <script>
            var person1 = {name: 'jerry', gender: 1};
            var person2 = {name: 'sherry', gender: 0};

            function show_name() {
                write(this.name);
            }
            show_name1 = show_name.bind(person1);
            show_name2 = show_name.bind(person2);
            show_name1();
            show_name2();

            person3={
                name:'claire',
                show:show_name,
                show1:show_name1,
                show2:show_name2
            };
            person3.show();
            person3.show1();
            person3.show2();
        </script>
    </li>
</ol>
</body>
</html>