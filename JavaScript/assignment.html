<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>ES6 变量的解构赋值</title>
</head>
<body>
<ol>
  <li>
    从数组中提取值，按照对应位置，对变量赋值。<br/>
    <samp>
      let [a, b, c] = [1, 2, 3];
    </samp>
  </li>
  <li>
    解构不成功，变量的值等于 undefined。<br/>
    <samp>
      let [a] = [];<br/>
      let [a, b] = [1];
    </samp>
  </li>
  <li>
    不完全解构。<br/>
    <samp>
      let [x, y] = [1, 2, 3];
    </samp>
  </li>
  <li>
    等号的右边不是数组（不是可遍历的结构），会报错。<br/>
    <samp>
      let [foo] = 1;<br/>
      let [foo] = false;<br/>
      let [foo] = NaN;<br/>
      let [foo] = undefined;<br/>
      let [foo] = null;<br/>
      let [foo] = {};
    </samp>
  </li>
  <li>
    默认值。<br/>
    <samp>
      let [foo = true] = []; //foo=true<br/>
      let [x, y = 'b'] = ['a']; // x='a', y='b'<br/>
      let [x, y = 'b'] = ['a', undefined]; // x='a', y='b'<br/>
      let [x = 1] = [undefined]; //x=1，只有当一个数组成员严格等于undefined，默认值才会生效<br/>
      let [x = 1] = [null]; //x=null
    </samp>
  </li>
  <li>
    表达式默认值。<br/>
    <samp>
      function f() { return 100; }<br/>
      let [x = f()] = [1]; //惰性求值的，即只有在用到的时候，才会求值。这里函数 f 不会执行。<hr/>
      function f() { return 100; }<br/>
      let [x = f()] = [undefined]; //x=100<br/>
    </samp>
  </li>
  <li>
    默认值可以引用解构赋值的其他变量，但该变量必须已经声明。<br/>
    <samp>
      let [x = 1, y = x] = [];     // x=1; y=1<br/>
      let [x = 1, y = x] = [2];    // x=2; y=2<br/>
      let [x = 1, y = x] = [1, 2]; // x=1; y=2<br/>
      let [x = y, y = 1] = [];     // ReferenceError: y is not defined
    </samp>
  </li>
</ol>

<ol>
  <li>
    对象的解构赋值。<br/>
    <samp>
      let { foo, bar, baz } = { foo: "aaa", bar: "bbb" }; //foo="aaa", bar="bbb", baz=undefined<br/>
      let { foo, baz, bar } = { foo: "aaa", bar: "bbb" }; //foo="aaa", bar="bbb", baz=undefined
    </samp>
  </li>
  <li>
    如果变量名与属性名不一致，必须写成这样。<br/>
    <samp>
      let { foo: baz } = { foo: 'aaa', bar: 'bbb' }; //baz='aaa'<br/>
      //从而得知对象解构的原型是：（左边对象的意义：把右边对象的foo键值赋值给变量foo，把右边对象的bar键值赋值给变量bar）<br/>
      let { foo: foo, bar: bar } = { foo: "aaa", bar: "bbb" }; //等价于简写的模式 let { foo, bar } = { foo: "aaa", bar: "bbb" }
    </samp>
  </li>
  <li>
    与数组一样，解构也可以用于嵌套结构的对象。<br/>
    <samp>
      let { p: [x, { y }] } = { p: [ 'Hello', { y: 'World' } ] }; //x='Hello', y='World'<br/>
      //这时 p 是模式，不是变量，因此不会被赋值。如果 p 也要作为变量赋值，可以写成下面这样：<br/>
      let { p, p: [x, { y }] } = { p: [ 'Hello', { y: 'World' } ] }; //x='Hello', y='World', p=[ 'Hello', { y: 'World' } ]<hr/>
      let { loc, loc: { start }, loc: { start: { line }} } = { loc: { start: { line: 1, column: 5 } } }; //注意，最后一次对line属性的解构赋值之中，只有line是变量，loc和start都是模式，不是变量。<hr/>
      let obj = {};<br/>
      let arr = [];<br/>
      ({ foo: obj.prop, bar: arr[0] } = { foo: 123, bar: true });

    </samp>
  </li>
  <li>
    对象的解构也可以指定默认值。默认值生效的条件是，对象的属性值严格等于 undefined。<br/>
    <samp>
      var {x = 3} = {}; //x = 3<br/>
      var {x, y = 5} = {x: 1}; //x = 1, y = 5<br/>
      var {x: y = 3} = {}; //y = 3<br/>
      var {x: y = 3} = {x: 5}; //y = 5<hr/>

      var { message: msg = 'Something went wrong' } = {};<br/>
      msg // "Something went wrong"<hr/>

      var {x = 3} = {x: undefined}; //x = 3<br/>
      var {x = 3} = {x: null}; //x = null
    </samp>
  </li>
  <li>
    如果解构失败，变量的值等于 undefined。<br/>
    <samp>
      let {foo} = {bar: 'baz'};<br/>
      foo // undefined
    </samp>
  </li>
  <li>
    对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。<br/>
    <samp>
      let { log, sin, cos } = Math;<hr/>

      let { log, warn } = console;<br/>
      log('hello world');<br/>
      warn('this is a warn.');
    </samp>
  </li>
  <li>
    对数组进行对象属性的解构。<br/>
    <samp>
      let arr = [1, 2, 3];<br/>
      let {0 : first, [arr.length - 1] : last} = arr; //first=1, last=3
    </samp>
  </li>
</ol>

<ol>
  <li>
    字符串的解构赋值。<br/>
    <samp>
      let [a, b, c, d, e] = 'hello';
    </samp>
  </li>
  <li>
    数值和布尔值的解构赋值。<br/>
    <samp>
      let {toString: s} = 123;<br/>
      s === Number.prototype.toString // true<hr/>

      let {toString: s} = true;<br/>
      s === Boolean.prototype.toString // true
    </samp>
  </li>
  <li>
    函数参数的解构赋值。<br/>
    <samp>
      function add([x, y]){ return x + y; }<br/>
      add([1, 2]); // 3<hr/>

      [[1, 2], [3, 4]].map(([a, b]) => a + b);<hr/>

      function move({x = 0, y = 0} = {}) { return [x, y]; }<br/>
      move({x: 3, y: 8}); // [3, 8]<br/>
      move({x: 3}); // [3, 0]<br/>
      move({}); // [0, 0]<br/>
      move(); // [0, 0]
    </samp>
  </li>
  <li>
    交换变量的值。<br/>
    <samp>
      let x = 1;<br/>
      let y = 2;<br/>
      [x, y] = [y, x];
    </samp>
  </li>
</ol>
</body>
</html>