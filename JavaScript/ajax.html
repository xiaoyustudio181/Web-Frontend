<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>test</title>
</head>
<body>

</body>
<script>
    //关于回调函数
    function callback(var1) {
        //alert(var1);
    }
    //调用匿名函数
    (function () {
        (function () {
            var temp=123;
            callback(temp);//取到匿名函数中的变量（拿到函数内部值的过程就是回滚函数）
            //回调函数就是为了解决拿到函数内部的值而产生
        })()
    })()
</script>
<script>
    // 关于 XMLHttpRequest, Ajax
    // XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。
    // 它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。
    // 这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。
    // 通过它，你可以很容易的取回一个 URL 上的资源数据。
    // 尽管名字里有 XML，但 XMLHttpRequest 可以取回所有类型的数据资源，并不局限于 XML。
    // 而且除了 HTTP ，它还支持 file 和 ftp 协议。

    // 构造函数初始化一个 XMLHttpRequest 对象。必须在所有其他方法被调用前调用构造函数。
    // 此接口继承了 XMLHttpRequestEventTarget 和 EventTarget 的属性。

    console.dir(XMLHttpRequest);
    var rq=new XMLHttpRequest();
    console.dir(rq);
    /*
     属性，类型，描述。
     =====================================
     onreadystatechange，Function?，一个JavaScript函数对象，当readyState属性改变时会调用它。回调函数会在user interface线程中调用。警告: 不能在本地代码中使用. 也不应该在同步模式的请求中使用。
     =====================================
     readyState，unsigned short，请求的五种状态，【值，状态，描述】，
     0，UNSENT (未打开)，open()方法还未被调用；
     1，OPENED(未发送)，open()方法已经被调用；
     2，HEADERS_RECEIVED(已获取响应头)，send()方法已经被调用，响应头和响应状态已经返回；
     3，LOADING(正在下载响应体)，响应体下载中，responseText中已经获取了部分数据；
     4，DONE(请求完成)，整个请求过程已经完毕。

     0: 请求未初始化
     1: 服务器连接已建立
     2: 请求已接收
     3: 请求处理中
     4: 请求已完成，且响应已就绪
     =====================================
     response，varies，响应实体的类型由 responseType 来指定，可以是 ArrayBuffer， Blob， Document， JavaScript 对象 (即 "json")，或者是字符串。如果请求未完成或失败，则该值为 null。
     =====================================
     responseText，DOMString，此次请求的响应为文本，或是当请求未成功或还未发送时为 null。只读。
     =====================================
     responseType，XMLHttpRequestResponseType，设置该值能够改变响应类型。就是告诉服务器你期望的响应格式。【值，响应属性的数据类型】""(空字符串)，字符串(默认值)；"arraybuffer"，ArrayBuffer；"blob"，Blob；"document"，Document；"json"，JavaScript对象，解析自服务器传递回来的JSON 字符串；"text"，字符串。
     =====================================
     responseXML，Document?，本次请求的响应是一个 Document 对象，如果是以下情况则值为 null：请求未成功，请求未发送，或响应无法被解析成 XML 或 HTML。当响应为text/xml 流时会被解析。当 responseType 设置为"document"，并且请求为异步的，则响应会被当做 text/html 流来解析。只读。注意: 如果服务器不支持 text/xml Content-Type 头，你可以使用 overrideMimeType() 强制 XMLHttpRequest 将响应解析为 XML。
     =====================================
     status，unsigned short，该请求的响应状态码 (例如, 状态码200 表示一个成功的请求)。只读。
     200: "OK"
     404: 未找到页面
     =====================================
     statusText，DOMString，该请求的响应状态信息，包含一个状态码和原因短语 (例如 "200 OK")。只读。
     =====================================
     upload，XMLHttpRequestUpload，可以在 upload 上添加一个事件监听来跟踪上传过程。
     =====================================
     withCredentials，boolean，表明在进行跨站(cross-site)的访问控制(Access-Control)请求时，是否使用认证信息(例如cookie或授权的header)。 默认为 false。注意: 这不会影响同站(same-site)请求。
     */
    /*
    方法，描述。
     =====================================
     abort()
     如果请求已经被发送,则立刻中止请求.
     =====================================
     getAllResponseHeaders()
     DOMString getAllResponseHeaders();
     返回所有响应头信息(响应头名和值), 如果响应头还没接受,则返回null. 注意: 对于多部分的请求，这里只从当前请求部分返回头部，而不会从原始通道。
     For multipart requests, this returns the headers from the current part of the request, not from the original channel.
     =====================================
     getResponseHeader()
     DOMString? getResponseHeader(DOMString header);
     返回指定的响应头的值，如果响应头还没被接受,或该响应头不存在,则返回null.
     =====================================
     open()
     初始化一个请求，该方法用于JavaScript代码中；如果是本地代码, 使用 openRequest()方法代替。注意：在一个已经激活的request下（已经调用open()或者openRequest()方法的request）再次调用这个方法相当于调用了abort()方法。
     void open(
         DOMString method,
         DOMString url,
         optional boolean async,
         optional DOMString user,
         optional DOMString password
     );
     参数
     method，请求所使用的HTTP方法; 例如 "GET", "POST", "PUT", "DELETE"等，如果下个参数是非HTTP(S)的URL,则忽略该参数；
     url，该请求所要访问的URL；
     async，一个可选的布尔值参数，默认为true,意味着是否执行异步操作，如果值为false,则send()方法不会返回任何东西，直到接受到了服务器的返回数据。如果为值为true，一个对开发者透明的通知会发送到相关的事件监听者。这个值必须是true,如果multipart 属性是true，否则将会出现一个意外。
     user，用户名，可选参数，为授权使用，默认参数为空字符串。
     password，密码，可选参数，为授权使用，默认参数为空字符串。
     overrideMimeType()，重写由服务器返回的MIME type。这个可用于，例如强制把一个响应流当作“text/xml”来处理和解析,即使服务器没有指明数据是这个类型。注意，这个方法必须在send()之前被调用。
     =====================================
     void overrideMimeType(DOMString mimetype);
     send()
     发送请求，如果该请求是异步模式(默认)，该方法会立刻返回。相反，如果请求是同步模式，则直到请求的响应完全接受以后，该方法才会返回。注意:所有相关的事件绑定必须在调用send()方法之前进行。
     void send();
     void send(ArrayBuffer data);
     void send(Blob data);
     void send(Document data);
     void send(DOMString? data);
     void send(FormData data);
     注意：如果发送的数据是个文档，它会在发送之前进行序列化。当发送一个文档，Firefox高于3的版本会对发送的请求使用UTF-8编码；Firefox 3 也可以支持发送文档的时候通过使用body.xmlEncoding指定编码方式，如果不指定则默认使用UTF-8编码。
     If it's an nsIInputStream, it must be compatible with nsIUploadChannel's setUploadStream()method. In that case, a Content-Length header is added to the request, with its value obtained using nsIInputStream's available()method. Any headers included at the top of the stream are treated as part of the message body. The stream's MIMEtype should be specified by setting the Content-Type header using the setRequestHeader()method prior to calling send().
     =====================================
     setRequestHeader()
     给指定的HTTP请求头赋值.在这之前,你必须确认已经调用 open() 方法打开了一个url。
     void setRequestHeader(DOMString header,DOMString value);
     参数：header，将要被赋值的请求头名称；value，给指定的请求头赋的值。
     */

    //rq.open("GET","demo.php?r=" + Math.random(),true);//以防从缓存载入，所以加上随机get参数
    rq.open("POST","/ajax_test.php",true);
    rq.onreadystatechange=function()//只有在异步模式才能使用
    {
        if (rq.readyState==4 && rq.status==200)//请求成功
        {
            //console.log(rq.response);
        }
    };
    rq.setRequestHeader("Content-type","application/x-www-form-urlencoded");
    rq.responseType='json';
    //rq.send('a=123&b=qwe');
    //console.log(rq);//内部response字段即返回结果
</script>
</html>