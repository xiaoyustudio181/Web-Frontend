<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>vue component</title>
    <!--<script src="https://unpkg.com/vue"></script>-->
    <script src="vue.js"></script>
</head>
<body>
<!--
第一个自定义组件
-->
<div id="comp1">
    <mycomponent1></mycomponent1>
</div>
<script>
    Vue.component('mycomponent1',{
        template:'<p style="color:blue;">my first component</p>'
    });
    new Vue({el:'#comp1'});
</script>
<hr />
<!--
局部注册
-->
<div id="comp1-2">
    <mycomponent2></mycomponent2>
</div>
<script>
    var Child={
        template: '<p>my second component</p>'
    };
    new Vue({
        el:'#comp1-2',
        components:{
            mycomponent2:Child
        }
    });
</script>
<hr />
<!--
自定义<tr>组件
-->
<div id="comp2">
    <table cellpadding="0" cellspacing="0" border="1">
        <tr is="myrow"></tr>
        <tr is="myrow"></tr>
        <!--
自定义组件 <my-row> 会被当作无效的内容，因此会导致错误的渲染结果。变通的方案是使用特殊的 is 特性：
<table>
  <tr is="my-row"></tr>
</table>
应当注意，如果使用来自以下来源之一的字符串模板，则没有这些限制：
<script type="text/x-template">
JavaScript 内联模板字符串
.vue 组件
        -->
    </table>
</div>
<script>
    Vue.component('myrow',{//tr is用法
        template:'<tr style="height: 35px;"><mytd></mytd><mytd></mytd></tr>'
    });
    Vue.component('mytd',{
        template:'<td>content</td>'
    });
    new Vue({el:'#comp2'});
</script>
<hr />
<!--
自定义组件的数据
-->
<div id="comp3">
    <mycounter></mycounter>
    <mycounter></mycounter>
</div>
<script>
    Vue.component('mycounter',{//普通事件
        template:'<button @click="counter++">{{counter}}</button>',
        data:function () {
            return { counter: 0 };
        }
    });
    new Vue({el:'#comp3'});
</script>
<hr />
<!--
自定义组件调用父级事件
-->
<div id="comp5">
    <mycounter2 v-on:event1="increaseSum"></mycounter2>
    <mycounter2 v-on:event1="increaseSum"></mycounter2> {{total}}<br />
</div>
<script>
    Vue.component('mycounter2',{
        template:'<button v-on:click="increase">{{counter}}</button>',
        data:function () {
            return { counter: 0 };
        },
        methods: {
            increase: function () {
                this.counter += 1;
                this.$emit('event1');//触发父级事件
            }
        }
    });
    new Vue({el:'#comp5',
        data:{
            total:0
        },
        methods:{
            increaseSum: function () {
                this.total ++;
            }
        }
    });
</script>
<hr />
<!--
驼峰法命名
自定义组价属性prop
注意在 JavaScript 中对象和数组是引用类型，指向同一个内存空间，如果 prop 是一个对象或数组，在子组件内部改变它会影响父组件的状态。
-->
<div id="comp4">
    <mycomponent2 message="hello"></mycomponent2>
    <mycomponent3 my-message="world"></mycomponent3>
    <hr />
    <input v-model="bindval" />
    <mycomponent2 :message="bindval"></mycomponent2>
</div>
<script>
    Vue.component('mycomponent2', {//props用法
        props: ['message'],//像data一样，prop也可以在模板中使用，同样可在vm实例中通过this.message来使用
        template: '<span>{{ message }}</span>'
    });
    Vue.component('mycomponent3', {//props驼峰命名法用法
        template: '<span>{{ myMessage }}</span>',
        props: ['myMessage']//HTML特性是不区分大小写的。所以，当使用的不是字符串模板时，camelCase(驼峰式命名)的prop 需要转换为相对应的kebab-case (短横线分隔式命名)
    });
    new Vue({el:'#comp4',
        data:{
            bindval:'screen'
        }
    });
</script>
<hr />
<!--
自定义列表组件
-->
<div id="comp6">
    <ul>
        <todo v-for="each in list" v-bind:item="each" v-bind:key="each.id">
            <!--key是为了使vue重用和重新排序现有元素，而不复用-->
        </todo>
    </ul>
</div>
<script>
    Vue.component('todo', {//props直接绑定对象属性
        props: ['item'],
        template: '<li>{{ item.txt }}</li>'
    });
    new Vue({
        el:'#comp6',
        data:{
            list: [
                { id: 1, txt: 'java' },
                { id: 2, txt: 'c#' },
                { id: 3, txt: 'php' }
            ]
        }});
</script>
<hr />
<!--
使用自定义事件的表单输入组件
-->
<div id="comp7">
    <currency></currency>
</div>
<script>
    Vue.component('currency', {
        template: '\
    <span>\
    $\
      <input ref="input1" aa="a1" v-bind:value="value" v-on:input="updateValue($event.target.value)" >\
      <span ref="span1"></span>\
    </span>',
        props: ['value'],
        methods: {
            updateValue: function (value) {//不直接更新值，而用此方法来对输入值进行格式化和位数限制
                var formattedValue = value.trim().slice(0, value.indexOf('.') === -1 ? value.length : value.indexOf('.') + 3);//保留2位小数
                if (formattedValue !== value) {// 如果值尚不合规，则覆盖为合规的值
                    this.$refs.input1.value = formattedValue;
                    this.$refs.span1.innerHTML='functioned';
                }
                //this.$emit('input', Number(formattedValue));//通过input事件带出数值
            }
        }
    });
    new Vue({el:'#comp7'});
</script>
<!--=======================================================-->
<hr />
<!--
单个插槽
-->
<div id="comp8">
    <parent-component></parent-component>
</div>
<script type="text/x-template" id="child1">
    <div>
        <h4>我是子组件的标题</h4>
        <slot>
            只有在没有要分发的内容时才会显示。
        </slot>
    </div>
</script>
<script type="text/x-template" id="parent1">
    <div>
        <h3>单个插槽</h3>
        <child-component>
            <!--<p>这是一些初始内容</p>
            <p>这是更多的初始内容</p>-->
        </child-component>
    </div>
</script>
<script>
    Vue.component('child-component', {
        template: '#child1'
    });
    Vue.component('parent-component', {
        template: '#parent1'
    });
    new Vue({el:'#comp8'});
</script>
<hr />
<!--
具名插槽
-->
<div id="comp9">
    <parent-component2></parent-component2>
</div>
<script type="text/x-template" id="child2">
    <div class="container">
        <header>
            <slot name="header"></slot>
        </header>
        <main>
            <slot></slot>
        </main>
        <footer>
            <slot name="footer"></slot>
        </footer>
    </div>
</script>
<script type="text/x-template" id="parent2">
    <child-component2>
        <h3 slot="header">具名插槽</h3>

        <p>主要内容的一个段落。</p>
        <p>另一个主要段落。</p>

        <p slot="footer">这里有一些联系信息</p>
    </child-component2>
</script>
<script>
    Vue.component('child-component2', {
        template: '#child2'
    });Vue.component('parent-component2', {
        template: '#parent2'
    });
    new Vue({el:'#comp9'});
</script>
<hr />
<!--

-->

</body>
</html>