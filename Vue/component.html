<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>vue component</title>
    <!--<script src="https://unpkg.com/vue"></script>-->
    <script src="vue.js"></script>
</head>
<body>
<!--
第一个自定义组件
-->
<div id="comp1">
    <mycomponent1></mycomponent1>
</div>
<script>
    Vue.component('mycomponent1',{
        template:'<p style="color:blue;">my first component</p>'
    });
    new Vue({el:'#comp1'});
</script>
<hr />
<!--
局部注册
-->
<div id="comp1-2">
    <mycomponent2></mycomponent2>
</div>
<script>
    var Child={
        template: '<p>my second component</p>'
    };
    new Vue({
        el:'#comp1-2',
        components:{
            mycomponent2:Child
        }
    });
</script>
<hr />
<!--
自定义<tr>组件
-->
<div id="comp2">
    <table cellpadding="0" cellspacing="0" border="1">
        <tr is="myrow"></tr>
        <tr is="myrow"></tr>
        <!--
自定义组件 <my-row> 会被当作无效的内容，因此会导致错误的渲染结果。变通的方案是使用特殊的 is 特性：
<table>
  <tr is="my-row"></tr>
</table>
应当注意，如果使用来自以下来源之一的字符串模板，则没有这些限制：
<script type="text/x-template">
JavaScript 内联模板字符串
.vue 组件
        -->
    </table>
</div>
<script>
    Vue.component('myrow',{//tr is用法
        template:'<tr style="height: 35px;"><mytd></mytd><mytd></mytd></tr>'
    });
    Vue.component('mytd',{
        template:'<td>content</td>'
    });
    new Vue({el:'#comp2'});
</script>
<hr />
<!--
自定义组件的数据
-->
<div id="comp3">
    <mycounter></mycounter>
    <mycounter></mycounter>
</div>
<script>
    Vue.component('mycounter',{//普通事件
        template:'<button @click="counter++">{{counter}}</button>',
        data:function () {
            return { counter: 0 };
        }
    });
    new Vue({el:'#comp3'});
</script>
<hr />
<!--
自定义组件调用父级事件
使用 v-on 绑定自定义事件
每个 Vue 实例都实现了事件接口，即：
使用 $on(eventName) 监听事件
使用 $emit(eventName) 触发事件
-->
<div id="comp5">
    <mycounter2 v-on:event1="increaseSum"></mycounter2>
    <mycounter2 v-on:event1="increaseSum"></mycounter2> {{total}}<br />
</div>
<script>
    Vue.component('mycounter2',{
        template:'<button v-on:click="increase">{{counter}}</button>',
        data:function () {
            return { counter: 0 };
        },
        methods: {
            increase: function () {
                this.counter += 1;
                this.$emit('event1');//触发父级事件
            }
        }
    });
    new Vue({el:'#comp5',
        data:{
            total:0
        },
        methods:{
            increaseSum: function () {
                this.total ++;
            }
        }
    });
</script>
<hr />
<!--
自定义组件的属性prop
驼峰法命名
注意在 JavaScript 中对象和数组是引用类型，指向同一个内存空间，如果 prop 是一个对象或数组，在子组件内部改变它会影响父组件的状态。
-->
<div id="comp4">
    <mycomponent2 message="hello"></mycomponent2>
    <mycomponent3 my-message="world"></mycomponent3>
    <hr />
    <input v-model="bindval" />
    <mycomponent2 :message="bindval"></mycomponent2>
</div>
<script>
    Vue.component('mycomponent2', {//props用法
        props: ['message'],//像data一样，prop也可以在模板中使用，同样可在vm实例中通过this.message来使用
        template: '<span>{{ message }}</span>'
    });
    Vue.component('mycomponent3', {//props驼峰命名法用法
        template: '<span>{{ myMessage }}</span>',
        props: ['myMessage']//HTML特性是不区分大小写的。所以，当使用的不是字符串模板时，camelCase(驼峰式命名)的prop 需要转换为相对应的kebab-case (短横线分隔式命名)
    });
    new Vue({el:'#comp4',
        data:{
            bindval:'screen'
        }
    });
</script>
<hr />
<!--
prop验证
非prop特性：可以直接传入组件，而不需要定义相应的 prop。如下例中的noprop="temp"
若组件的class的值来自两个方向，一个来自组件定义，一个来自父组件，
对于多数特性来说，传递给组件的值会覆盖组件本身设定的值。即例如传递 type="large" 将会覆盖 type="date" 且有可能破坏该组件！所幸我们对待 class 和 style 特性会更聪明一些，这两个特性的值都会做合并 (merge) 操作。
-->
<div id="comp4-2">
    <example :prop-a="1" prop-b="2"
             prop-c="hi" prop-f="11" noprop="temp"></example>
    <!--字面量语法 vs 动态语法
    初学者常犯的一个错误是使用字面量语法传递数值：<comp some-prop="1"></comp>
    因为它是一个字面量 prop，它的值是字符串 "1" 而不是一个数值。
    如果想传递一个真正的 JavaScript 数值，则需要使用 v-bind，从而让它的值被当作 JavaScript 表达式计算：<comp v-bind:some-prop="1"></comp>
    -->
</div>
<script>
    Vue.component('example', {
        template:'<div>prop验证测试 ' +
        'A: {{propA}}, ' +
        'B: {{propB}}, ' +
        'C: {{propC}}, ' +
        'D: {{propD}}, ' +
        'E: {{propE}}, ' +
        'F: {{propF}}' +
        '</div>',
        props: {
            propA: Number,// 基础类型检测 (`null` 指允许任何类型)
            propB: [String, Number],// 可能是多种类型
            propC: {// 必传且是字符串
                type: String,
                required: true
            },
            propD: {// 数值且有默认值
                type: Number,
                default: 100
            },
            propE: {// 数组/对象的默认值应当由一个工厂函数返回
                type: Object,
                default: function () {
                    return { message: 'hello' };
                }
            },
            propF: {// 自定义验证函数
                validator: function (value) {
                    return value > 10;
                }
            }
            //type 可以是这些原生构造器：
            //String, Number, Boolean, Function, Object, Array, Symbol
            //type 也可以是一个自定义构造器函数，使用 instanceof 检测。

            //当 prop 验证失败，Vue 会抛出警告 (如果使用的是开发版本)。
            //注意 prop 会在组件实例创建之前进行校验，所以在 default 或 validator 函数里，诸如 data、computed 或 methods 等实例属性还无法使用。
        }
    });
    new Vue({
        el:'#comp4-2',
        data:{
            temp:''
        }
    });
</script>
<hr />
<!--

-->

<hr />
<!--
自定义列表组件
-->
<div id="comp6">
    <ul>
        <todo v-for="each in list" v-bind:item="each" v-bind:key="each.id">
            <!--key是为了使vue重用和重新排序现有元素，而不复用-->
        </todo>
    </ul>
</div>
<script>
    Vue.component('todo', {//props直接绑定对象属性
        props: ['item'],
        template: '<li>{{ item.txt }}</li>'
    });
    new Vue({
        el:'#comp6',
        data:{
            list: [
                { id: 1, txt: 'java' },
                { id: 2, txt: 'c#' },
                { id: 3, txt: 'php' }
            ]
        }});
</script>
<hr />
<!--
使用自定义事件的表单输入组件
-->
<div id="comp7">
    <currency></currency>
</div>
<script>
    Vue.component('currency', {
        template: '\
    <span>\
    $\
      <input ref="input1" aa="a1" v-bind:value="value" v-on:input="updateValue($event.target.value)" >\
      <span ref="span1"></span>\
    </span>',
        props: ['value'],
        methods: {
            updateValue: function (value) {//不直接更新值，而用此方法来对输入值进行格式化和位数限制
                var formattedValue = value.trim().slice(0, value.indexOf('.') === -1 ? value.length : value.indexOf('.') + 3);//保留2位小数
                if (formattedValue !== value) {// 如果值尚不合规，则覆盖为合规的值
                    this.$refs.input1.value = formattedValue;
                    this.$refs.span1.innerHTML='functioned';
                }
                //this.$emit('input', Number(formattedValue));//通过input事件带出数值
            }
        }
    });
    new Vue({el:'#comp7'});
</script>
<!--=======================================================-->
<hr />
<!--
单个插槽
-->
<div id="comp8">
    <parent-component></parent-component>
</div>
<script type="text/x-template" id="child1">
    <div>
        <h4>我是子组件的标题</h4>
        <slot>
            只有在没有要分发的内容时才会显示。
        </slot>
    </div>
</script>
<script type="text/x-template" id="parent1">
    <div>
        <h3>单个插槽</h3>
        <child-component>
            <!--<p>这是一些初始内容</p>
            <p>这是更多的初始内容</p>-->
        </child-component>
    </div>
</script>
<script>
    Vue.component('child-component', {
        template: '#child1'
    });
    Vue.component('parent-component', {
        template: '#parent1'
    });
    new Vue({el:'#comp8'});
</script>
<hr />
<!--
具名插槽
-->
<div id="comp9">
    <parent-component2></parent-component2>
</div>
<script type="text/x-template" id="child2">
    <div class="container">
        <header>
            <slot name="header"></slot>
        </header>
        <main>
            <slot></slot>
        </main>
        <footer>
            <slot name="footer"></slot>
        </footer>
    </div>
</script>
<script type="text/x-template" id="parent2">
    <child-component2>
        <h3 slot="header">具名插槽</h3>

        <p>主要内容的一个段落。</p>
        <p>另一个主要段落。</p>

        <p slot="footer">这里有一些联系信息</p>
    </child-component2>
</script>
<script>
    Vue.component('child-component2', {
        template: '#child2'
    });
    Vue.component('parent-component2', {
        template: '#parent2'
    });
    new Vue({el:'#comp9'});
</script>
<hr />
<!--

-->

</body>
</html>